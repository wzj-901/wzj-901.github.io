<!DOCTYPE html>
<html>
<head><title>拟合</title>
    <style>
        body { margin: 0;overflow:hidden; height: 100vh; display: flex; }
        #tableArea { width: 300px; border-right: 1px solid black; overflow: auto; }
        #rightArea { flex: 1; display: flex; flex-direction: column; }
        #inputArea { height: 300px; border-bottom: 1px solid black; }
        #bottomArea { flex: 1; display: flex; }
        #imageArea { width: 500px; border-right: 1px solid black; position: relative; }
        #settingsArea { flex: 1; }
        
        table { width: 100%; border-collapse: collapse; }
        td { border: 1px solid #ddd; padding: 0; }
        input { width: 100%; border: none; padding: 5px; box-sizing: border-box; }
        textarea {box-sizing: border-box;font-size: 20px;font-family: Arial;font-family: "Consolas", "Monaco", "Courier New", monospace;
        width: 100%; height: 100%; padding: 10px; resize: none; border: none; }
        canvas { position: absolute; top: 0; left: 0; }

        
        /* 新增样式 */
        #settingsBtn {
            position: absolute;
            left: 5px;
            top: 460px;
            font-size: 30px;
            background: rgba(0, 0, 0, 0);
            border: 0px solid #999;
            cursor: pointer;
            opacity: 0;
            z-index: 100;
            color:#777;
            transition: all 0.3s linear;
            font-weight:bold;
            padding: 0px;
            line-height: 25.3px;
        }
        #settingsBtn.mobile {
            left: 470px;
        }
        #myCanvas:hover~#settingsBtn {
            opacity: 0.6;
        }
        
        #settingsBtn:hover {
            opacity: 1;
        }
        
/* 基础容器 */
.settings-panel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 260px;
    height: 300px;
    display: none;
    background: #86cca055;
    border: 1px solid #ddd;
    border-radius: 10px;
    box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(2px);
    padding: 12px;
    z-index: 1000;
    font-size: 17px;
}
.settings-panel.mobile {
    right: 10px;
    top: -3px;
    left: unset;
}
.settings-panel *{
    background-color: #0000;
    font-family: "微软雅黑";
    line-height:0.5;
}

/* 每个 div 独占一行，并添加间距 */
.settings-panel > div {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    padding: 5px 0;
}
/* 输入框样式 */
.settings-panel input:not([type="checkbox"]) {
    width: 40px;
    text-align: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    outline: none;
    border: none;
    background: transparent;
    padding: 0;
    margin: 0 -5px;
    color: #333;
    border-bottom: 1.5px solid transparent; /* 初始透明下划线 */
    transition: border-bottom 0.2s ease;
    font-size: 17px;
}
.settings-panel input:not([type="checkbox"]):hover{
    border-bottom: 1.5px solid #0c49a0; /* 蓝色下划线 */
    color:#0c49a0;
    box-shadow: none;
    
}
#num3 input,#num4 input {width:82px}
/* 复选框样式 */
.settings-panel input[type="checkbox"] {
    margin-right: 8px;
    width: 16px;
    height: 16px;
    pointer-events: none;
}

/* 下拉选择框样式 */
.settings-panel select {
    width: calc(100% - 60px);
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 9px;
    background-color: rgba(255, 255, 255, 0.8);
}

/* 标签文字样式 */
.settings-panel p {
    margin: 0 5px;
    color: #333;
}

/* 最后一个 div 不需要下边距 */
.settings-panel > div:last-child {
    margin-bottom: 0;
}

#num0{
    user-select: none;
}
#num0:hover p{
    color: #0c49a0;
}
#num5 input{
    width: 50px;
}
#num6{
    position: flex;user-select: none;
    align-items: center;
    width: 82px;
    margin-left: 10px;
}
#num6 span{
    position: relative;
    top:-2px;
    left:-5px
}
    </style>
</head>
<body>
    <div id="tableArea">
        <table id="dataTable">
            <tbody></tbody>
        </table>
    </div>
    
    <div id="rightArea">
        <div id="inputArea">
            <textarea id="inputText" placeholder="语音输入区，Ctrl+Enter 执行。   
x#开头设x轴名称
x=开头后语音（或手动）批量输入数据
x=>开头批量操作 eg: x=>⌊0.5*I⌋ ，y=>ln(y) 
拟合类型：指数/对数-x/y  B样条
>> 或 0>> nxyz 输出表格"></textarea>
        </div>
        <div id="bottomArea">
            <div id="imageArea">
                <canvas id="myCanvas"></canvas>
                <button id="settingsBtn">⚙</button>
            </div>
            <div id="settingsArea">
				<textarea id="inputText2"></textarea></div>
        </div>
    </div>
    <style>
        /* 竖屏覆盖样式 */
        @media (max-aspect-ratio: 1/1) {
            body { position: relative; display: block; }
            
            #tableArea {
                position: absolute;
                left: 0;
                bottom: 0;
                width: 300px !important;
                height: calc(100vh - 300px); /* 总高 - 输入区高度 */
            }
            
            #inputArea {
                position: absolute;
                top: 0;
                left: 0;
                width:100vw;
                height: 300px;
            }
            
            #bottomArea {
                position: absolute;
                top: 300px;  /* 输入区下方 */
                left: 300px;
                height: calc(100vh - 300px); /* 总高 - 输入区高度 */
                width: calc(100vw - 300px); /* 总宽 - 表格区宽度 */
            }
            
            #imageArea {
                width: 100% !important;
                height: 500px; /* 固定最小高度 */
                border-right: none;
                border-bottom: 1px solid black;
            }
            
            #settingsArea {
                position: absolute;
                top: 500px;  /* 图片区高度 */
                left: 0;
                right: 0;
                bottom: 0;
            }
        }
    </style>
    
    <script>
    </script>
    
<script>
// 新增配置参数
let viewportConfig = {
    fixed: false,
    autoPadding: { left: 5, right: 5, bottom: 5, top: 5 },
    fixedRange: { xMin: 0, xMax: 10, yMin: 0, yMax: 10 },
    fitType: 'linear', fitType_B: 3, lineIt: false
};
var variables = {}
var variables2 = {}
var variablesContent="";

// 添加设置面板HTML
const settingsPanel = document.createElement('div');
settingsPanel.id = 'settingsPanel';
settingsPanel.className = 'settings-panel';
settingsPanel.innerHTML = `
    <div id="num0" onclick='fixedViewport.checked=!fixedViewport.checked;viewportConfig.fixed=fixedViewport.checked;toggleRangeInputs()'><input type="checkbox" id="fixedViewport"><p>固定视窗</p></div>
    <div id="num1"><p>外拓-X：</p><input class="padding-left"><p>%，</p><input class="padding-right"><p>%</p></div>
    <div id="num2"><p>　　-Y：</p><input class="padding-top"><p>%，</p><input class="padding-bottom"><p>%</p></div>
    <div id="num3"><p>X轴：(</p><input class="range-xMin"><p>，</p><input class="range-xMax"><p>)</p></div>
    <div id="num4"><p>Y轴：(</p><input class="range-yMin"><p>，</p><input class="range-yMax"><p>)</p></div>
    <div><select id="fitType"><option value="linear">线性拟合</option><option value="expX">指数X拟合</option><option value="expY">指数Y拟合</option><option value="logX">对数X拟合</option><option value="logY">对数Y拟合</option><option value="B">B样条拟合</option><option value="No">不拟合</option></select>
        
    <div id="num6" onclick='lineIt.checked=!lineIt.checked;viewportConfig.lineIt=lineIt.checked;toggleRangeInputs()'><p><input type="checkbox" id="lineIt"><span>连线</span></p></div>
        </div>
    <div id="num5"><p>关联近邻：</p><input type="number" min="1" max="30" value="3" step="1" class="B-r"></div>
    `;
document.getElementById('settingsArea').appendChild(settingsPanel);

// 面板显示控制
document.getElementById('settingsBtn').addEventListener('click', function(e) {
    const panel = document.getElementById('settingsPanel');
    panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
    e.stopPropagation();
});

// 响应式定位
function updatePanelPosition() {
    const panel = document.getElementById('settingsPanel');
    const btn = document.getElementById('settingsBtn');
    const isPortrait = window.matchMedia("(orientation: portrait)").matches;
    panel.className = `settings-panel ${isPortrait ? 'mobile' : ''}`;
    btn.className = `settingsBtn ${isPortrait ? 'mobile' : ''}`;
}
window.addEventListener('resize', updatePanelPosition);
updatePanelPosition();

// 获取DOM元素
const fixedViewport = document.getElementById('fixedViewport');
const fitType = document.getElementById('fitType');
const num1 = document.getElementById('num1');
const num2 = document.getElementById('num2');
const num3 = document.getElementById('num3');
const num4 = document.getElementById('num4');
const num5 = document.getElementById('num5');

// 初始化表单值
function initForm() {
    fixedViewport.checked = viewportConfig.fixed;
    fitType.value = viewportConfig.fitType;
    
    document.querySelector('.padding-left').value = viewportConfig.autoPadding.left;
    document.querySelector('.padding-right').value = viewportConfig.autoPadding.right;
    document.querySelector('.padding-top').value = viewportConfig.autoPadding.top;
    document.querySelector('.padding-bottom').value = viewportConfig.autoPadding.bottom;
    
    document.querySelector('.range-xMin').value = viewportConfig.fixedRange.xMin;
    document.querySelector('.range-xMax').value = viewportConfig.fixedRange.xMax;
    document.querySelector('.range-yMin').value = viewportConfig.fixedRange.yMin;
    document.querySelector('.range-yMax').value = viewportConfig.fixedRange.yMax;
    
    toggleRangeInputs();
}

// 切换输入框显示
function toggleRangeInputs() {
    if (fixedViewport.checked) {
        num1.style.display = 'none';
        num2.style.display = 'none';
        num3.style.display = 'flex';
        num4.style.display = 'flex';
    } else {
        num1.style.display = 'flex';
        num2.style.display = 'flex';
        num3.style.display = 'none';
        num4.style.display = 'none';
    }
    if(viewportConfig.fitType=="B"){
        num5.style.display="flex";
    }else{
        num5.style.display="none";
    }
}

// 绑定事件监听器
fixedViewport.addEventListener('change', function() {
    viewportConfig.fixed = this.checked;
    toggleRangeInputs();
});

fitType.addEventListener('change', function() {
    viewportConfig.fitType = this.value;
    paintType=this.value;
    toggleRangeInputs();
});

// 自动padding输入监听
document.querySelectorAll('.padding-left, .padding-right, .padding-top, .padding-bottom').forEach(input => {
    input.addEventListener('input', function() {
        viewportConfig.autoPadding[this.className.split('-')[1]] = parseFloat(this.value) || 0;
        this.style.color="#333";
        if(!parseFloat(this.value) && this.value!="0"){this.style.color="rgb(255, 0, 0)"}
    });
});

// 固定范围输入监听
document.querySelectorAll('.range-xMin, .range-xMax, .range-yMin, .range-yMax').forEach(input => {
    input.addEventListener('input', function() {
        const [axis, type] = this.className.split('-');
        viewportConfig.fixedRange[type] = parseFloat(this.value) || 0;
        this.style.color="#333";
        if(!parseFloat(this.value) && this.value!="0"){this.style.color="rgb(255, 0, 0)"}
    });
});

// B样条阶数输入监听
document.querySelectorAll('.B-r').forEach(input => {
    input.addEventListener('input', function() {
        viewportConfig.fitType_B = parseInt(this.value) || 3;
        this.style.color="#333";
        if(!parseInt(this.value) || this.value<1 || this.value>30){this.style.color="rgb(255, 0, 0)"}
    });
});

// 初始化
initForm();

let a = [[, "x", "y", "z"]];
for(let i=0;i<200;i++){a.push(["","","",""])}
function initTable() {
    const tbody = document.querySelector('#dataTable tbody');
    tbody.innerHTML = '';
    
    // 始终显示a.length+1行
    for(let i=0; i<a.length; i++) {  // 修改循环条件
        const tr = document.createElement('tr');
        
        // 行号列
        const td0 = document.createElement('td');
        td0.innerHTML = `<input class="row-number" value="${i}" disabled>`;
        tr.appendChild(td0);
        
        // 数据列
        for(let j=1; j<4; j++) {
            const td = document.createElement('td');
            const value = '';
            td.innerHTML = `<input value="${value}" 
                                data-row="${i}"
                                data-col="${j}"
                                oninput="syncData(${i},${j},this.value)"
                                onkeydown="handleKey(event, ${i}, ${j})">`;  // 新增键盘事件
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
}
// 新增键盘导航函数
function handleKey(e, row, col) {
    const key = e.key;
    const inputs = document.querySelectorAll('[data-row]');
    
    if(key.startsWith('Arrow')||key=="Enter") {
        e.preventDefault();
        let newRow = row;
        let newCol = col;
        
        switch(key) {
            case 'ArrowUp': newRow = Math.max(0, row-1); break;
            case 'ArrowDown':case 'Enter': newRow = row+1; break;
            case 'ArrowLeft': newCol = Math.max(1, col-1); break;
            case 'ArrowRight': newCol = Math.min(3, col+1); break;
        }
        
        const selector = `[data-row="${newRow}"][data-col="${newCol}"]`;
        const target = document.querySelector(selector);
        target?.focus();
    }
}

const Get=(x,y)=>document.querySelector(`[data-row="${x}"][data-col="${y}"]`);
function setALL(){
	for(let i=0;i<a.length;i++){
		for(let j=1;j<4;j++){
			Get(i,j).value=a[i][j];
		}
	}	
}
setTimeout("setALL()",0);
// 数据同步函数
function syncData(i, j, value) {
    a[i][j] = value;
    console.log('Updated a:', a);
}

// 输入监听
document.getElementById('inputText').addEventListener('keydown', e => {
    if(e.ctrlKey && e.key === 'Enter') {
        fill(e.target.value);
        e.preventDefault();
    }
});

// 初始化执行
initTable();

const canvas = document.getElementById('myCanvas');
const dpi = window.devicePixelRatio;
canvas.width = 500 * dpi;
canvas.height = 500 * dpi;
canvas.style.width = "500px";
canvas.style.height = "500px";

const ctx = canvas.getContext('2d');
ctx.scale(dpi, dpi);

// B样条相关函数
// 生成节点向量，n为控制点数，k为阶数
function generateKnots(n, k) {
    const knots = [];
    for (let i = 0; i <= k; i++) knots.push(0); // 左侧重复k+1次
    for (let i = 1; i <= n - k - 1; i++) {
        knots.push(i / (n - k)); // 均匀分布中间节点
    }
    for (let i = 0; i <= k; i++) knots.push(1); // 右侧重复k+1次
    return knots;
}

// 计算B样条基函数，i为控制点索引，k为阶数，t为参数，U为节点向量
function bsplineBasis(i, k, t, U) {
    if (k === 0) {
        return (U[i] <= t && t < U[i + 1]) || (t === 1 && i === U.length - 2) ? 1 : 0;
    }
    const denom1 = U[i + k] - U[i];
    const denom2 = U[i + k + 1] - U[i + 1];
    const term1 = denom1 !== 0 ? ((t - U[i]) / denom1) * bsplineBasis(i, k - 1, t, U) : 0;
    const term2 = denom2 !== 0 ? ((U[i + k + 1] - t) / denom2) * bsplineBasis(i + 1, k - 1, t, U) : 0;
    return term1 + term2;
}
function ShowContent(){
    document.getElementById("inputText2").value=variablesContent;
}

function Paint(){
    variablesContent="";
    setTimeout(()=>ShowContent(),0)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(0, 0, 500, 500);
    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#000';
    ctx.moveTo(100, 100);
    ctx.lineTo(100, 440);
    ctx.lineTo(440, 440);
    ctx.stroke();
    variables2={...variables};
    variables={};

    var a2 = [];
    for(let i=1; i<a.length; i++){
        var x = Number(a[i][1]);
        var y = Number(a[i][2]);
        if((x || a[i][1]===0 || a[i][1]==="0") && (y || a[i][2]===0 || a[i][2]==="0")){
            let valid = true;
            if (viewportConfig.fitType === 'logX' && x <= 0) valid = false;
            if (viewportConfig.fitType === 'logY' && y <= 0) valid = false;
            if (viewportConfig.fitType === 'expX' && x <= 0) valid = false;
            if (viewportConfig.fitType === 'expY' && y <= 0) valid = false;
            if (valid) a2.push([x, y]);
        }
    }    
    if(a2.length>0){
        // 通用统计计算函数
        const calculateStats = (values) => {
            const n = values.length;
            if (n === 0) return null;

            const sum = values.reduce((acc, val) => acc + val, 0);
            const mean = sum / n;
            const sumOfSquares = values.reduce((acc, val) => acc + val ** 2, 0);
            const sumSquaredDiff = values.reduce((acc, val) => acc + (val - mean) ** 2, 0);
            let stdDev;
            try {
                stdDev = n > 1 ? Math.sqrt(sumSquaredDiff / (n - 1)).toPrecision(9) : '-';
            } catch (e) {
                stdDev = 'Error';
            }
            return {
                n,
                sum: sum.toPrecision(9),
                mean: mean.toPrecision(9),
                sumSq: sumOfSquares.toPrecision(9),
                sumSquaredDiff: sumSquaredDiff.toPrecision(9),
                stdDev
            };
        };

        // 提取x,y数据
        const xValues = a2.map(pair => pair[0]).filter(v => typeof v === 'number');
        const yValues = a2.map(pair => pair[1]).filter(v => typeof v === 'number');

        // 计算统计量
        const xStats = calculateStats(xValues);
        const yStats = calculateStats(yValues);

        // 动态构建输出内容
        const outputBuilder = [];
        if (xStats) {
            outputBuilder.push(`
【X统计】------------------
n      : ${xStats.n}
Σx     : ${xStats.sum}
x̄      : ${xStats.mean}
Σx²    : ${xStats.sumSq}
Σ(x-x̄)²: ${xStats.sumSquaredDiff}
σ_x    : ${xStats.stdDev}`.trim());
variables["n"]=xStats.n;
variables["Σx²"]=xStats.sumSq;
variables["Σx"]=xStats.sum;
variables["x̄"]=xStats.mean;
variables["Σ(x-x̄)²"]=xStats.sumSquaredDiff;
variables["σ_x"]=xStats.stdDev;
        }
        if (yStats) {
            outputBuilder.push(`
【Y统计】------------------
n      : ${yStats.n}
Σy     : ${yStats.sum}
ȳ      : ${yStats.mean}
Σy²    : ${yStats.sumSq}
Σ(y-ȳ)²: ${yStats.sumSquaredDiff}
σ_y    : ${yStats.stdDev}`.trim());
variables["n"]=yStats.n;
variables["Σy²"]=yStats.sumSq;
variables["Σy"]=yStats.sum;
variables["ȳ"]=yStats.mean;
variables["Σ(y-ȳ)²"]=yStats.sumSquaredDiff;
variables["σ_y"]=yStats.stdDev;
        }
        variablesContent = outputBuilder.length > 0 ? outputBuilder.join('\n\n') : "";


        a2.sort((a, b) => a[0] - b[0]);
        var Xmin2 = a2[0][0];
        var Xmax2 = a2[a2.length-1][0];
        delX = Xmax2 - Xmin2;
        Psize = 4;
        var a3 = JSON.parse(JSON.stringify(a2));
        a3.sort((a, b) => a[1] - b[1]);
        var Ymin2 = a3[0][1];
        var Ymax2 = a3[a3.length-1][1];
        delY = Ymax2 - Ymin2;

        if(viewportConfig.fixed){
            Xmin = viewportConfig.fixedRange.xMin;
            Xmax = viewportConfig.fixedRange.xMax;
            Ymin = viewportConfig.fixedRange.yMin;
            Ymax = viewportConfig.fixedRange.yMax;
        }else{
            Xmin = Xmin2 - delX * 0.01 * viewportConfig.autoPadding.left;
            Xmax = Xmax2 + delX * 0.01 * viewportConfig.autoPadding.right;
            Ymin = Ymin2 - delY * 0.01 * viewportConfig.autoPadding.top;
            Ymax = Ymax2 + delY * 0.01 * viewportConfig.autoPadding.bottom;
        }
        
        // 数据坐标到画布坐标
        function changeXY(x, y){
            return [(x - Xmin) / (Xmax - Xmin) * 340 + 100, (Ymax - y) / (Ymax - Ymin) * 340 + 100];
        }

        // 画布坐标到数据坐标（反函数）
        function inverseChangeXY(px, py){
            const x = Xmin + (px - 100) / 340 * (Xmax - Xmin);
            const y = Ymax - (py - 100) / 340 * (Ymax - Ymin);
            return [x, y];
        }

        if(viewportConfig.lineIt){
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#888';
            ctx.moveTo(...changeXY(...a2[0]));
            for(let i=1; i<a2.length; i++){
                ctx.lineTo(...changeXY(...a2[i]));
            }
            ctx.stroke();
        }

        for(let i=0; i<a2.length; i++){
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000';
            ctx.fillRect(changeXY(...a2[i])[0] - Psize/2, changeXY(...a2[i])[1] - Psize/2, Psize, Psize);
        }   
        ctx.beginPath();
        ctx.font = '25px Arial';
        ctx.fillStyle = '#555';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(a[0][1], 280, 495);

        ctx.font = '25px Arial';
        ctx.fillStyle = '#555';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        xa = 12;
        ya = 250;
        ctx.save();
        ctx.translate(xa, ya);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(a[0][2], 0, 0);
        ctx.restore();

        switch(viewportConfig.fitType){
            case "linear":
                var Result = linearRegression(a2);
                var k = Result.k;
                var b = Result.b;
                var r = Result.r;
                var SE_k = Result.SE_k;
                var SE_b = Result.SE_b;

                ctx.beginPath();
                ctx.font = '15px Arial';
                ctx.fillStyle = '#555';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                var text = `y=k*x+b\nk=${k.toPrecision(8)}±${SE_k.toPrecision(4)}\nb=${b.toPrecision(8)}±${SE_b.toPrecision(4)}\nr=${r.toPrecision(10)}`;
                text = text.split(/\n/g);
                text.forEach((t, i) => { ctx.fillText(t, 300, 10 + i * 20); });
variablesContent =variablesContent.replace("\n\n","\n")+`
【线性回归】---------------
k      : ${k.toPrecision(10)}
b      : ${b.toPrecision(10)}
r      : ${r.toPrecision(10)}
σ_k    : ${SE_k.toPrecision(4)}
σ_b    : ${SE_b.toPrecision(4)}`
variables["k"]=k;
variables["b"]=b;
variables["r"]=r;
variables["σ_k"]=SE_k;
variables["σ_b"]=SE_b;
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#f00';
                ctx.moveTo(...changeXY(Xmin2, k * Xmin2 + b));
                ctx.lineTo(...changeXY(Xmax2, k * Xmax2 + b));
                ctx.stroke();
                break;
                case "logX":
                    var transformedData = a2.map(([x, y]) => [Math.log(x), y]);
                    var Result = linearRegression(transformedData);
                    var k = Result.k;
                    var b = Result.b;
                    var r = Result.r;
                    var SE_k = Result.SE_k;
                    var SE_b = Result.SE_b;

                    ctx.beginPath();
                    ctx.font = '15px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    var text = "y=k*ln(x)+b\nk=" + k.toPrecision(8) + "±" + SE_k.toPrecision(4) + "\nb=" + b.toPrecision(8) + "±" + SE_b.toPrecision(4) + "\nr=" + r.toPrecision(10);
                    text = text.split(/\n/g);
                    text.forEach((t, i) => { ctx.fillText(t, 300, 10 + i * 20); });
                    variablesContent =variablesContent.replace("\n\n","\n") + "\n【对数X拟合】-------------\nk      : " + k.toPrecision(10) + "\nb      : " + b.toPrecision(10) + "\nr      : " + r.toPrecision(10) + "\nσ_k    : " + SE_k.toPrecision(4) + "\nσ_b    : " + SE_b.toPrecision(4);
                    variables["k"]=k;
                    variables["b"]=b;
                    variables["r"]=r;
                    variables["σ_k"]=SE_k;
                    variables["σ_b"]=SE_b;
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#f00';
                    var steps = 100;
                    for (let i = 0; i <= steps; i++) {
                        let x = Xmin2 + (Xmax2 - Xmin2) * (i / steps);
                        if (x <= 0) continue;
                        let y = k * Math.log(x) + b;
                        let [px, py] = changeXY(x, y);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    break;
                case "expY":
                    var transformedData = a2.map(([x, y]) => [x, Math.exp(y)]);
                    var Result = linearRegression(transformedData);
                    var k = Result.k;
                    var b = Result.b;
                    var r = Result.r;
                    var SE_k = Result.SE_k;
                    var SE_b = Result.SE_b;

                    ctx.beginPath();
                    ctx.font = '15px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    var text = "exp(y)=k*x+b\nk=" + k.toPrecision(8) + "±" + SE_k.toPrecision(4) + "\nb=" + b.toPrecision(8) + "±" + SE_b.toPrecision(4) + "\nr=" + r.toPrecision(10);
                    text = text.split(/\n/g);
                    text.forEach((t, i) => { ctx.fillText(t, 300, 10 + i * 20); });
                    variablesContent =variablesContent.replace("\n\n","\n") + "\n【指数Y拟合】-------------\nk      : " + k.toPrecision(10) + "\nb      : " + b.toPrecision(10) + "\nr      : " + r.toPrecision(10) + "\nσ_k    : " + SE_k.toPrecision(4) + "\nσ_b    : " + SE_b.toPrecision(4);
                    variables["k"]=k;
                    variables["b"]=b;
                    variables["r"]=r;
                    variables["σ_k"]=SE_k;
                    variables["σ_b"]=SE_b;
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#f00';
                    var steps = 100;
                    for (let i = 0; i <= steps; i++) {
                        let x = Xmin2 + (Xmax2 - Xmin2) * (i / steps);
                        let y = Math.log(k * x + b);
                        if (k * x + b <= 0) continue;
                        let [px, py] = changeXY(x, y);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    break;
                case "expX":
                    var transformedData = a2.map(([x, y]) => [Math.exp(x), y]);
                    var Result = linearRegression(transformedData);
                    var k = Result.k;
                    var b = Result.b;
                    var r = Result.r;
                    var SE_k = Result.SE_k;
                    var SE_b = Result.SE_b;

                    ctx.beginPath();
                    ctx.font = '15px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    var text = "y=k*exp(x)+b\nk=" + k.toPrecision(8) + "±" + SE_k.toPrecision(4) + "\nb=" + b.toPrecision(8) + "±" + SE_b.toPrecision(4) + "\nr=" + r.toPrecision(10);
                    text = text.split(/\n/g);
                    text.forEach((t, i) => { ctx.fillText(t, 300, 10 + i * 20); });
                    variablesContent =variablesContent.replace("\n\n","\n") + "\n【指数X拟合】-------------\nk      : " + k.toPrecision(10) + "\nb      : " + b.toPrecision(10) + "\nr      : " + r.toPrecision(10) + "\nσ_k    : " + SE_k.toPrecision(4) + "\nσ_b    : " + SE_b.toPrecision(4);
                    variables["k"]=k;
                    variables["b"]=b;
                    variables["r"]=r;
                    variables["σ_k"]=SE_k;
                    variables["σ_b"]=SE_b;
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#f00';
                    var steps = 100;
                    for (let i = 0; i <= steps; i++) {
                        let x = Xmin2 + (Xmax2 - Xmin2) * (i / steps);
                        let y = k * Math.exp(x) + b;
                        let [px, py] = changeXY(x, y);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    break;
                case "logY":
                    var transformedData = a2.map(([x, y]) => [x, Math.log(y)]);
                    var Result = linearRegression(transformedData);
                    var k = Result.k;
                    var b = Result.b;
                    var r = Result.r;
                    var SE_k = Result.SE_k;
                    var SE_b = Result.SE_b;

                    ctx.beginPath();
                    ctx.font = '15px Arial';
                    ctx.fillStyle = '#555';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    var text = "ln(y)=k*x+b\nk=" + k.toPrecision(8) + "±" + SE_k.toPrecision(4) + "\nb=" + b.toPrecision(8) + "±" + SE_b.toPrecision(4) + "\nr=" + r.toPrecision(10);
                    text = text.split(/\n/g);
                    text.forEach((t, i) => { ctx.fillText(t, 300, 10 + i * 20); });
                    variablesContent =variablesContent.replace("\n\n","\n") + "\n【对数Y拟合】-------------\nk      : " + k.toPrecision(10) + "\nb      : " + b.toPrecision(10) + "\nr      : " + r.toPrecision(10) + "\nσ_k    : " + SE_k.toPrecision(4) + "\nσ_b    : " + SE_b.toPrecision(4);
                    variables["k"]=k;
                    variables["b"]=b;
                    variables["r"]=r;
                    variables["σ_k"]=SE_k;
                    variables["σ_b"]=SE_b;
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#f00';
                    var steps = 100;
                    for (let i = 0; i <= steps; i++) {
                        let x = Xmin2 + (Xmax2 - Xmin2) * (i / steps);
                        let y = Math.exp(k * x + b);
                        let [px, py] = changeXY(x, y);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                    break;
            case "B":
                if (a2.length > viewportConfig.fitType_B) {
                    const n = a2.length;
                    const k = Math.min(viewportConfig.fitType_B, n - 1); // 确保阶数不超过控制点数
                    const U = generateKnots(n, k);
                    var steps = 100;
                    const tMin = U[k];
                    const tMax = U[n];
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#f00';
                    for (let s = 0; s < steps; s++) {
                        // 从视口Xmin到Xmax映射到t
                        const x = Xmin2 + (Xmax2 - Xmin2) * (s / steps);
                        const t = tMin + (tMax - tMin) * ((x - Xmin2) / (Xmax2 - Xmin2));
                        const clampedT = Math.max(tMin, Math.min(tMax, t)); // 限制t在有效范围内
                        let bx = 0, by = 0;
                        const bs=[]
                        for (let i = 0; i < n; i++) {
                            const B = bsplineBasis(i, k, clampedT, U);
                            bs.push(B);
                            bx += a2[i][0] * B;
                            by += a2[i][1] * B;
                        }
                        const [px, py] = changeXY(bx, by);
                        if (s === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                        //console.log(bs,px,py)
                    }
                    ctx.lineTo(...changeXY(...a2[a2.length-1]))
                    ctx.stroke();
                }
                break;
        }
        indexs1 = calculateAxisTicks(Xmin, Xmax);
        indexs2 = calculateAxisTicks(Ymin, Ymax);
        for(let i=0; i<indexs1.length; i++){
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000';
            ctx.moveTo(changeXY(indexs1[i], 0)[0], 440);
            ctx.lineTo(changeXY(indexs1[i], 0)[0], 445);
            ctx.stroke();
            ctx.beginPath();
            ctx.font = '15px Arial';
            ctx.fillStyle = '#555';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(indexs1[i], changeXY(indexs1[i], 0)[0], 450);
        }
        for(let i=0; i<indexs2.length; i++){
            ctx.beginPath();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#000';
            ctx.moveTo(100, changeXY(0, indexs2[i])[1]);
            ctx.lineTo(95, changeXY(0, indexs2[i])[1]);
            ctx.stroke();
            ctx.beginPath();
            ctx.font = '15px Arial';
            ctx.fillStyle = '#555';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(indexs2[i], 95, changeXY(0, indexs2[i])[1]);
        }
    }
}

function linearRegression(a2) {
    const x = a2.map(p => p[0]);
    const y = a2.map(p => p[1]);
    const n = x.length;

    if (n < 2) throw new Error("至少需要两个数据点");

    const xMean = x.reduce((a, v) => a + v, 0) / n;
    const yMean = y.reduce((a, v) => a + v, 0) / n;

    let varX = 0, cov = 0, varY = 0;
    for (let i = 0; i < n; i++) {
        const xiDiff = x[i] - xMean;
        const yiDiff = y[i] - yMean;
        varX += xiDiff ** 2;
        cov += xiDiff * yiDiff;
        varY += yiDiff ** 2;
    }

    if (varX === 0) throw new Error("x值不能全相同");

    const k = cov / varX;
    const b = yMean - k * xMean;
    const r = cov / (Math.sqrt(varX) * Math.sqrt(varY));

    let RSS = 0;
    for (let i = 0; i < n; i++) {
        RSS += (y[i] - (k * x[i] + b)) ** 2;
    }

    const sigmaSquared = RSS / (n - 2);
    const SE_k = Math.sqrt(sigmaSquared / varX);
    const SE_b = Math.sqrt(sigmaSquared * (1/n + xMean**2 / varX));

    return { k, b, r, SE_k, SE_b };
}

function calculateAxisTicks(Xmin, Xmax) {
    if (Xmin >= Xmax) return [];
    
    const magnitude = Math.pow(10, Math.floor(Math.log10(Xmax - Xmin)));
    let step = magnitude;
    
    const candidates = [0.1, 0.2, 0.25, 0.5, 1, 2, 2.5, 5, 10];
    for (const candidate of candidates) {
        const testStep = candidate * magnitude;
        const tickCount = Math.ceil((Xmax - Xmin) / testStep);
        if (tickCount <= 9 && tickCount >= 4) {
            step = testStep;
            break;
        }
    }

    let start = Math.ceil(Xmin / step) * step;
    start = Math.max(start, Xmin);
    let end = Math.floor(Xmax / step) * step;
    end = Math.min(end, Xmax);
    
    const ticks = [];
    for (let v = start; v <= end + 1e-10; v += step) {
        ticks.push(Math.abs((v.toPrecision(8)))<1e-10?0:Number(v.toPrecision(8)));
    }

    if (ticks.length < 5) {
        return calculateAxisTicks(Xmin, Xmax, step/2);
    }

    return ticks;
}

var xSeted = false;
var ySeted = false;
var xyLast = "x";
var paintType = viewportConfig.fitType;

function fill(x) {
    console.log('执行内容:', x);
    var lines = x.split("\n");
    lines.forEach(dealIt);
    setALL();
    // 移除强制重置fitType的代码，保留UI设置
    initForm();
    Paint(); // 立即绘制
}

function dealIt(x, i){
    if(x.startsWith("##")){return;}
    else if(x.startsWith("x=>")){Do2x(x.split("x=>")[1]);return;}
    else if(x.startsWith("y=>")){Do2y(x.split("y=>")[1]);return;}
    else if(x.startsWith("z=>")){Do2z(x.split("z=>")[1]);return;}
    else if(x.startsWith("x=")){Dox(x.split("x=")[1]);return;}
    else if(x.startsWith("y=")){Doy(x.split("y=")[1]);return;}
    else if(x.startsWith("z=")){Doz(x.split("z=")[1]);return;}
    else if(x.startsWith("x#")){a[0][1]=x.split("x#")[1] || a[0][1];return;}
    else if(x.startsWith("y#")){a[0][2]=x.split("y#")[1] || a[0][2];return;}
    else if(x.startsWith("z#")){a[0][3]=x.split("z#")[1] || a[0][3];return;}
    else if(x.startsWith("线性")){paintType="linear"; viewportConfig.fitType="linear"; return;}
    else if(x.startsWith("指数x")){paintType="expX"; viewportConfig.fitType="expX"; return;}
    else if(x.startsWith("对数x")){paintType="logX"; viewportConfig.fitType="logX"; return;}
    else if(x.startsWith("指数y")){paintType="expY"; viewportConfig.fitType="expY"; return;}
    else if(x.startsWith("对数y")){paintType="logY"; viewportConfig.fitType="logY"; return;}
    else if(x.startsWith("B拟合") || x.startsWith("B样条") || x.startsWith("b拟合") || x.startsWith("b样条")){
        paintType="B"; viewportConfig.fitType="B"; return;
    }else if(x.startsWith(">>")){generateTableText(x.replaceAll(">",""),0);return;}
    else if(x.startsWith("0>>")){generateTableText(x.split("0>>")[1].replaceAll(">",""),1);return;}
    
    if(!xSeted){Dox(x);return;}
    if(!ySeted){Doy(x);return;}
    if(xyLast=="x"){Dox(x);return;}
    if(xyLast=="y"){Doy(x);return;}
}function generateTableText(columns, precisionMode = 0) {
    // 筛选有效行
    let validRows = [];
    for (let i = 1; i < a.length; i++) {
        if ((a[i][1] || a[i][1] === 0 || a[i][1] === "0") && 
            (a[i][2] || a[i][2] === 0 || a[i][2] === "0")) {
            validRows.push([i, ...a[i].slice(1)]); // 包含正确序号
        }
    }

    // 列映射
    const colMap = { 'n': 0, 'x': 1, 'y': 2, 'z': 3 };

    // 按列收集数据以确定最大精度（precisionMode === 1 时使用）
    let maxPrecisions = { 1: 0, 2: 0, 3: 0 }; // x, y, z 列的最大小数位数
    if (precisionMode === 1) {
        validRows.forEach(row => {
            [1, 2, 3].forEach(col => {
                let value = row[col];
                if (value !== '' && value !== undefined) {
                    let str = value.toString();
                    let decimalPos = str.indexOf('.');
                    if (decimalPos !== -1) {
                        let precision = str.length - decimalPos - 1;
                        maxPrecisions[col] = Math.max(maxPrecisions[col], precision);
                    }
                }
            });
        });
    }

    // 生成表格文本
    let tableText = validRows.map(row => {
        return columns.split('').map(col => {
            const idx = colMap[col.toLowerCase()];
            let value = row[idx] !== undefined ? row[idx] : '';
            
            // precisionMode === 1 时补零
            if (precisionMode === 1 && idx > 0 && value !== '' && maxPrecisions[idx] > 0) {
                let str = value.toString();
                let decimalPos = str.indexOf('.');
                if (decimalPos === -1) {
                    str += '.' + '0'.repeat(maxPrecisions[idx]);
                } else {
                    let currentPrecision = str.length - decimalPos - 1;
                    if (currentPrecision < maxPrecisions[idx]) {
                        str += '0'.repeat(maxPrecisions[idx] - currentPrecision);
                    }
                }
                return str;
            }
            return value;
        }).join(',');
    }).join('\n');

    // 复制到剪贴板
    navigator.clipboard.writeText(tableText).then(() => {
        console.log('已复制到剪贴板:\n' + tableText);
    }).catch(err => {
        console.error('复制失败:', err);
    });

    // 输出到控制台
    console.log(tableText);
}
function Dox(x){
    x1 = deal3(x); console.log(x1);
    if(x1.length>0){
        for(let i=0; i<x1.length; i++){
            a[i+1][1] = x1[i];
        }
        xSeted = true;
        xyLast = "x";
    }
}

function Doy(x){
    x1 = deal3(x); console.log(x1);
    if(x1.length>0){
        for(let i=0; i<x1.length; i++){
            a[i+1][2] = x1[i];
        }
        ySeted = true;
        xyLast = "y";
    }
}

function Doz(x){
    x1 = deal3(x); console.log(x1);
    if(x1.length>0){
        for(let i=0; i<x1.length; i++){
            a[i+1][3] = x1[i];
        }
    }
}

function Do2x(xx){
    for(let i=1; i<a.length; i++){
        xx0 = xx;
        try{
            var x = a[i][1];
            var y = a[i][2];
            var z = a[i][3];
            a[i][1] = eval(maths(PREmaths(xx0).replace(/x/g,"("+x+")")
                                    .replace(/y/g,"("+y+")")
                                    .replace(/z/g,"("+z+")")
                                    .replace(/I/g,i)));
        }catch(e){console.log(e)}
    }
}

function Do2y(yy){
    for(let i=1; i<a.length; i++){
        yy0 = yy;
        try{
            var x = a[i][1];
            var y = a[i][2];
            var z = a[i][3];
            a[i][2] = eval(maths(PREmaths(yy0).replace(/x/g,"("+x+")")
                                    .replace(/y/g,"("+y+")")
                                    .replace(/z/g,"("+z+")")
                                    .replace(/I/g,i)));
        }catch(e){console.log(e)}
    }
}

function Do2z(zz){
    for(let i=1; i<a.length; i++){
        zz0 = zz;
        try{
            var x = a[i][1];
            var y = a[i][2];
            var z = a[i][3];
            a[i][3] = eval(maths(PREmaths(zz0).replace(/x/g,"("+x+")")
                                    .replace(/y/g,"("+y+")")
                                    .replace(/z/g,"("+z+")")
                                    .replace(/I/g,i)));
        }catch(e){console.log(e)}
    }
}
function PREmaths(x) {
    result=x;
    //console.log(variables2)
    for(let pat in variables2){
        if(pat.includes("x") || pat.includes("y")){result=result.replaceAll(pat,variables2[pat])};
    }
    result=result.replaceAll("exp","ep");
    return result;
}
function maths(x) {
    const replacements = [
        { pattern: /\barccosh\b/g, replacement: "Math.acosh" },
        { pattern: /\barcsinh\b/g, replacement: "Math.asi!nh" },
        { pattern: /\barctanh\b/g, replacement: "Math.ata!nh" },
        { pattern: /\barccos\b/g, replacement: "Math.acos" },
        { pattern: /\barcsin\b/g, replacement: "Math.asi!n" },
        { pattern: /\barctan\b/g, replacement: "Math.ata!n" },
        { pattern: /\bsinh\b/g, replacement: "Math.si!nh" },
        { pattern: /\bcosh\b/g, replacement: "Math.cosh" },
        { pattern: /\btanh\b/g, replacement: "Math.ta!nh" },
        { pattern: /\bsin\b/g, replacement: "Math.si!n" },
        { pattern: /\bcos\b/g, replacement: "Math.cos" },
        { pattern: /\btan\b/g, replacement: "Math.ta!n" },
        { pattern: /\bln\b/g, replacement: "Math.log" },
        { pattern: /\bep\b/g, replacement: "Math.exp" },
        { pattern: /\bsqrt\b/g, replacement: "Math.sqrt" },
        { pattern: /\bpow\b/g, replacement: "Math.pow" },
        { pattern: /\babs\b/g, replacement: "Math.abs" },
        { pattern: /\bround\b/g, replacement: "Math.rou!nd" },
        { pattern: /\bfloor\b/g, replacement: "Math.floor" },
        { pattern: /\bceil\b/g, replacement: "Math.ceil" },
        { pattern: /\bE\b/g, replacement: "Math.E" },
        { pattern: /\bπ\b/g, replacement: "Math.PI" },
        { pattern: /\^/g, replacement: "**" },
        { pattern: /⌊/g, replacement: "Math.floor(" },
        { pattern: /⌋/g, replacement: ")" },
        { pattern: /⌈/g, replacement: "Math.ceil(" },
        { pattern: /⌉/g, replacement: ")" },
    ];
    let result = x.replace(/Math\./g, "");
    for (const { pattern, replacement } of replacements) {
        result = result.replace(pattern, replacement);
    }
    result = result.replaceAll("!n","###1###")
    console.log(variables2)
    for(let pat in variables2){
        if(!(pat.includes("x") || pat.includes("y"))){result=result.replaceAll(pat,variables2[pat])};
    }
    result = result.replaceAll("###1###","n");
    return result;
}
function Y(x){
    var n0=NaN;
    if ((variables2.k || variables2.k===0) && (variables2.b || variables2.b===0)) {
        if (paintType === "linear") n0 = variables2.k * x + variables2.b;
        else if (paintType === "logX" && x > 0) n0 = variables2.k * Math.log(x) + variables2.b;
        else if (paintType === "expY" && variables2.k * x + variables2.b > 0) n0 = Math.log(variables2.k * x + variables2.b);
        else if (paintType === "expX") n0 = variables2.k * Math.exp(x) + variables2.b;
        else if (paintType === "logY") n0 = Math.exp(variables2.k * x + variables2.b);
    }
    return n0;
}
function X(y){
    var n0=NaN;
    if (variables2.k && (variables2.b || variables2.b===0)) {
        if (paintType === "linear") n0 = (y - variables2.b) / variables2.k;
        else if (paintType === "logX") n0 = Math.exp((y - variables2.b) / variables2.k);
        else if (paintType === "expY") n0 = (Math.exp(y) - variables2.b) / variables2.k;
        else if (paintType === "expX") n0 = Math.log((y - variables2.b) / variables2.k);
        else if (paintType === "logY" && y > 0) n0 = (Math.log(y) - variables2.b) / variables2.k;
    }
    return n0;
}
function deal3(x) {
    let aa = [];
    let current = '';
    let hasDot = false;

    const isDigit = c => /\d/.test(c);
    const isSpace = c => /\s/.test(c);
    const isSeparator = c => /[，。,.；;：:+-正负]/.test(c);

    for (const c of x) {
        if (isDigit(c) || isSpace(c) || c === '.') {
            if (c === '.') {
                if ((current.match(/\./g) || []).length >= 1) {
                    const lastNeg = current.lastIndexOf('-');
                    const lastSpace = current.lastIndexOf(' ');
                    const splitIndex = lastNeg>0?lastNeg:lastSpace;
                    if (splitIndex !== -1) {
                        aa.push(current.substring(0, splitIndex + 1));
                        current = current.substring(splitIndex + 1) + '.';
                    } else {
                        aa.push(current);
                        current = '.';
                    }
                } else {
                    current += c;
                }
            } else {
                current += c;
            }
        } else if (isSeparator(c)) {
            aa.push(current);
            current = /[+-]/.test(c) ? c : '';
        } else {
            current += ' ';
        }
    }

    if (current) aa.push(current);

    return aa
        .map(s => s.replace(/\s/g, ''))
        .filter(s => s !== '')
        .map(s => {
            try { return s === '-' || s === '+' ? NaN : Number(s); } 
            catch { return NaN; }
        })
        .filter(n => !isNaN(n));
}

setInterval("Paint()", 500);

function setCookie(cname, cvalue, exdays){
    var d = new Date();
    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
    var expires = "expires=" + d.toGMTString();
    document.cookie = cname + "=" + encodeURIComponent(cvalue) + "; " + expires;
}

function getCookie(cname){
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name)==0) { return decodeURIComponent(c.substring(name.length, c.length)); }
    }
    return "";
}

var aaa = getCookie("textvalue");
if(aaa){
    x = aaa;
    document.getElementById("inputText").value = x ? (x.startsWith("##") ? "" : "##") + x.replace(/\n##/g, "\n").replace(/\n/g, "\n##") : x;
}
setInterval(`setCookie("textvalue", document.getElementById('inputText').value||"", 100)`, 1000);
</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'938fa4b31913b01c',t:'MTc0NjEwNjMzMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>